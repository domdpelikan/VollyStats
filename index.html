</span></p>
                        </div>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500 pl-12">Today's Passes (${passCount} total):</p>
                        <p class="text-gray-700 break-words pl-12">${passCount > 0 ? todayPasses.join(', ') : 'No passes recorded for today.'}</p>
                    </div>
                </div>`;
            };

            const groups = [ { title: 'Liberos', positions: ['Libero'] }, { title: 'Outsides', positions: ['Outside'] }, { title: 'Middles / Opposites / Setters', positions: ['Middle', 'Opposite', 'Setter'] }];
            
            let finalHtml = groups.map(group => {
                const playersInGroup = players
                    .filter(p => p.position && group.positions.includes(p.position))
                    .map(p => ({ ...p, dailyAverage: getPlayerDailyAverage(p) }))
                    .sort((a, b) => b.dailyAverage - a.dailyAverage);

                if (playersInGroup.length === 0) return '';

                let rankCounter = 1;
                const groupHtml = playersInGroup.map((player) => {
                    const rank = player.dailyAverage >= 0 ? rankCounter++ : null;
                    return playerCardHtml(player, rank);
                }).join('');

                return `<div class="mb-6"><h2 class="text-xl font-semibold text-gray-700 pb-2 mb-3 border-b-2 border-indigo-200">${group.title}</h2><div class="space-y-3">${groupHtml}</div></div>`;
            }).join('');

            const unassignedPlayers = players.filter(p => !p.position).sort((a,b)=>a.name.localeCompare(b.name));
            if (unassignedPlayers.length > 0) {
                 const unassignedHtml = unassignedPlayers.map(player => playerCardHtml(player, null)).join('');
                 finalHtml += `<div class="mb-6"><h2 class="text-xl font-semibold text-gray-700 pb-2 mb-3 border-b-2 border-gray-200">Unassigned</h2><div class="space-y-3">${unassignedHtml}</div></div>`;
            }

            statsList.innerHTML = finalHtml || `<div class="bg-white p-4 rounded-lg shadow-sm text-center text-gray-500">No players found.</div>`;
            
            let totalPasses = 0;
            let totalSum = 0;
            players.forEach(player => {
                const todayPasses = (player.statsByDate || {})[todayKey] || [];
                totalPasses += todayPasses.length;
                totalSum += todayPasses.reduce((sum, current) => sum + current, 0);
            });
            const teamAverage = totalPasses > 0 ? (totalSum / totalPasses).toFixed(2) : '0.00';
            teamSummarySection.innerHTML = `<div class="bg-indigo-600 text-white p-6 rounded-lg shadow-lg"><h2 class="text-2xl font-bold text-center mb-4">Today's Team Summary</h2><div class="flex justify-around text-center"><div><p class="text-lg font-semibold text-indigo-200">Total Passes</p><p class="text-4xl font-bold">${totalPasses}</p></div><div><p class="text-lg font-semibold text-indigo-200">Team Average</p><p class="text-4xl font-bold">${teamAverage}</p></div></div></div>`;
        };

        const renderLog = (players) => {
            document.getElementById('log-loading')?.remove();
            const allDates = new Set();
            players.forEach(player => { if (player.statsByDate) { Object.keys(player.statsByDate).forEach(dateKey => { if (dateKey !== todayKey) { allDates.add(dateKey); } }); } });
            const sortedDates = Array.from(allDates).sort().reverse();
            if (sortedDates.length === 0) { logSection.innerHTML = `<div class="bg-white p-4 rounded-lg shadow-sm text-center text-gray-500">No past practice data found.</div>`; return; }
            const groups = [ { title: 'Liberos', positions: ['Libero'] }, { title: 'Outsides', positions: ['Outside'] }, { title: 'Middles / Opposites / Setters', positions: ['Middle', 'Opposite', 'Setter'] }];
            logSection.innerHTML = sortedDates.map(dateKey => {
                const displayDate = new Date(dateKey + 'T00:00:00').toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                const playersWithStatsOnDate = players.filter(p => p.statsByDate && p.statsByDate[dateKey] && p.statsByDate[dateKey].length > 0);
                if (playersWithStatsOnDate.length === 0) return '';

                let teamTotalPassesOnDate = 0;
                let teamTotalSumOnDate = 0;
                players.forEach(p => {
                    const passes = (p.statsByDate || {})[dateKey] || [];
                    teamTotalPassesOnDate += passes.length;
                    teamTotalSumOnDate += passes.reduce((s, c) => s + c, 0);
                });
                const teamAverageOnDate = teamTotalPassesOnDate > 0 ? (teamTotalSumOnDate / teamTotalPassesOnDate).toFixed(2) : '0.00';

                let playerHtml = groups.map(group => {
                    const playersInGroup = playersWithStatsOnDate.filter(p => p.position && group.positions.includes(p.position)).sort((a, b) => a.name.localeCompare(b.name));
                    if (playersInGroup.length === 0) return '';
                    const playerRows = playersInGroup.map(player => {
                        const passes = player.statsByDate[dateKey] || [];
                        const count = passes.length; const sum = passes.reduce((s, c) => s + c, 0); const avg = (sum/count).toFixed(2);
                        return `<div class="flex justify-between items-center py-2 border-b border-gray-100"><span class="font-medium">${player.name}</span><span class="text-gray-600">Avg: <span class="font-bold text-gray-800">${avg}</span> (${count} passes)</span></div>`;
                    }).join('');
                    return `<h3 class="text-md font-semibold text-indigo-700 mt-4 mb-2">${group.title}</h3><div>${playerRows}</div>`;
                }).join('');
                const unassignedPlayers = playersWithStatsOnDate.filter(p => !p.position).sort((a,b) => a.name.localeCompare(b.name));
                if (unassignedPlayers.length > 0) {
                     const playerRows = unassignedPlayers.map(player => {
                        const passes = player.statsByDate[dateKey] || [];
                        const count = passes.length; const sum = passes.reduce((s, c) => s + c, 0); const avg = (sum/count).toFixed(2);
                        return `<div class="flex justify-between items-center py-2 border-b border-gray-100"><span class="font-medium">${player.name}</span><span class="text-gray-600">Avg: <span class="font-bold text-gray-800">${avg}</span> (${count} passes)</span></div>`;
                    }).join('');
                    playerHtml += `<h3 class="text-md font-semibold text-indigo-700 mt-4 mb-2">Unassigned</h3><div>${playerRows}</div>`;
                }
                return `<div class="bg-white rounded-lg shadow-md">
                    <div class="log-toggle p-6 cursor-pointer">
                        <div class="flex justify-between items-center">
                            <div>
                                <h2 class="text-xl font-bold text-gray-800">${displayDate}</h2>
                                <p class="text-sm text-gray-500">Team Average: <span class="font-semibold">${teamAverageOnDate}</span> (${teamTotalPassesOnDate} passes)</p>
                            </div>
                             <div class="flex items-center space-x-4">
                                <button data-date-key="${dateKey}" class="change-date-btn text-sm text-indigo-600 hover:underline font-semibold z-10 relative">Change Date</button>
                                <svg class="chevron-icon w-6 h-6 text-gray-400 transform transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                </svg>
                            </div>
                        </div>
                    </div>
                    <div class="log-details hidden px-6 pb-6">
                        <div class="border-t pt-4">
                            ${playerHtml}
                        </div>
                    </div>
                </div>`;
            }).join('');
        };

        const renderProgress = (players) => {
            document.getElementById('progress-loading')?.remove();
            if (players.length === 0) {
                progressSection.innerHTML = `<div class="bg-white p-4 rounded-lg shadow-sm text-center text-gray-500">Add players to the roster to see progress charts.</div>`;
                return;
            }
            progressSection.innerHTML = '';
            players.sort((a, b) => a.name.localeCompare(b.name)).forEach(player => {
                const statsByDate = player.statsByDate || {};
                const practiceDates = Object.keys(statsByDate).sort();
                
                const chartContainer = document.createElement('div');
                chartContainer.className = 'bg-white p-6 rounded-lg shadow-md';
                chartContainer.id = `chart-container-${player.id}`;
                progressSection.appendChild(chartContainer);

                if (practiceDates.length < 2) {
                     chartContainer.innerHTML = `<h3 class="font-bold text-lg text-indigo-700">${player.name}</h3><p class="text-gray-500 text-sm mt-2">Not enough data to show progress. At least two practices are needed.</p>`;
                    return;
                }
                const chartData = { labels: [], averages: [] };
                practiceDates.forEach(dateKey => {
                    const passes = statsByDate[dateKey] || [];
                    if (passes.length > 0) {
                        const sum = passes.reduce((s, c) => s + c, 0);
                        const avg = sum / passes.length;
                        chartData.labels.push(new Date(dateKey + 'T00:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                        chartData.averages.push(avg);
                    }
                });

                chartContainer.innerHTML = `<h3 class="font-bold text-lg text-indigo-700 mb-4">${player.name}'s Progress</h3>`;
                const canvas = document.createElement('canvas');
                chartContainer.appendChild(canvas);

                if (playerCharts[player.id]) { playerCharts[player.id].destroy(); }
                playerCharts[player.id] = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { labels: chartData.labels, datasets: [{ label: 'Passing Average', data: chartData.averages, borderColor: '#4f46e5', backgroundColor: 'rgba(79, 70, 229, 0.1)', fill: true, tension: 0.1 }] },
                    options: { scales: { y: { beginAtZero: true, max: 3 } }, responsive: true, maintainAspectRatio: true }
                });
            });
        };

        const renderHittingStatsList = (players) => {
            document.getElementById('hitting-stats-loading')?.remove();
            if (players.length === 0) {
                hittingStatsList.innerHTML = `<div class="bg-white p-4 rounded-lg shadow-sm text-center text-gray-500">Add players to the roster to start tracking hitting stats.</div>`;
                downloadHittingCsvBtn.disabled = true;
                hittingTeamSummarySection.innerHTML = '';
                return;
            }
            downloadHittingCsvBtn.disabled = false;

            const getPlayerHittingStats = (player) => {
                const hittingByDate = player.hittingByDate || {};
                const todayHits = hittingByDate[todayKey] || { kills: 0, errors: 0 };
                const totalAttempts = todayHits.kills + todayHits.errors;
                const hitPercentage = totalAttempts > 0 ? ((todayHits.kills / totalAttempts) * 100) : 0;
                return { kills: todayHits.kills, errors: todayHits.errors, totalAttempts, hitPercentage, hasData: totalAttempts > 0 };
            };

            const playerCardHtml = (player, rank) => {
                const stats = getPlayerHittingStats(player);
                const rankHtml = rank
                    ? `<span class="text-2xl font-bold text-gray-400 w-8 text-center">${rank}.</span>`
                    : `<span class="text-2xl font-bold text-gray-300 w-8 text-center">-</span>`;
                
                const percentDisplay = stats.hasData ? stats.hitPercentage.toFixed(1) + '%' : '0.0%';
                const mainTextColor = rank ? 'text-indigo-700' : 'text-gray-500';
                const opacityClass = rank ? '' : 'opacity-60';

                return `
                <div class="bg-white p-4 rounded-lg shadow-sm ${opacityClass}">
                    <div class="flex items-center space-x-4">
                        ${rankHtml}
                        <div>
                            <h3 class="font-bold text-lg ${mainTextColor} hitting-player-name-link cursor-pointer hover:underline" data-player-id="${player.id}">${player.name}</h3>
                            <p class="text-sm text-gray-500">Hit %: <span class="font-semibold text-xl text-gray-800">${percentDisplay}</span></p>
                        </div>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500 pl-12">Today's Stats:</p>
                        <p class="text-gray-700 pl-12"><span class="text-green-600 font-semibold">${stats.kills} Kills</span> | <span class="text-red-600 font-semibold">${stats.errors} Errors</span> | ${stats.totalAttempts} Total</p>
                    </div>
                </div>`;
            };

            const groups = [ { title: 'Liberos', positions: ['Libero'] }, { title: 'Outsides', positions: ['Outside'] }, { title: 'Middles / Opposites / Setters', positions: ['Middle', 'Opposite', 'Setter'] }];
            
            let finalHtml = groups.map(group => {
                const playersInGroup = players
                    .filter(p => p.position && group.positions.includes(p.position))
                    .map(p => ({ ...p, hittingStats: getPlayerHittingStats(p) }))
                    .sort((a, b) => b.hittingStats.hitPercentage - a.hittingStats.hitPercentage);

                if (playersInGroup.length === 0) return '';

                let rankCounter = 1;
                const groupHtml = playersInGroup.map((player) => {
                    const rank = player.hittingStats.hasData ? rankCounter++ : null;
                    return playerCardHtml(player, rank);
                }).join('');

                return `<div class="mb-6"><h2 class="text-xl font-semibold text-gray-700 pb-2 mb-3 border-b-2 border-indigo-200">${group.title}</h2><div class="space-y-3">${groupHtml}</div></div>`;
            }).join('');

            const unassignedPlayers = players.filter(p => !p.position).sort((a,b)=>a.name.localeCompare(b.name));
            if (unassignedPlayers.length > 0) {
                 const unassignedHtml = unassignedPlayers.map(player => playerCardHtml(player, null)).join('');
                 finalHtml += `<div class="mb-6"><h2 class="text-xl font-semibold text-gray-700 pb-2 mb-3 border-b-2 border-gray-200">Unassigned</h2><div class="space-y-3">${unassignedHtml}</div></div>`;
            }

            hittingStatsList.innerHTML = finalHtml || `<div class="bg-white p-4 rounded-lg shadow-sm text-center text-gray-500">No players found.</div>`;
            
            let totalKills = 0;
            let totalErrors = 0;
            players.forEach(player => {
                const todayHits = (player.hittingByDate || {})[todayKey] || { kills: 0, errors: 0 };
                totalKills += todayHits.kills;
                totalErrors += todayHits.errors;
            });
            const totalAttempts = totalKills + totalErrors;
            const teamHitPercent = totalAttempts > 0 ? ((totalKills / totalAttempts) * 100).toFixed(1) : '0.0';
            hittingTeamSummarySection.innerHTML = `<div class="bg-green-600 text-white p-6 rounded-lg shadow-lg"><h2 class="text-2xl font-bold text-center mb-4">Today's Team Hitting</h2><div class="flex justify-around text-center"><div><p class="text-lg font-semibold text-green-200">Total Kills</p><p class="text-4xl font-bold">${totalKills}</p></div><div><p class="text-lg font-semibold text-green-200">Total Errors</p><p class="text-4xl font-bold">${totalErrors}</p></div><div><p class="text-lg font-semibold text-green-200">Hit %</p><p class="text-4xl font-bold">${teamHitPercent}%</p></div></div></div>`;
        };

        const renderHittingLog = (players) => {
            document.getElementById('hitting-log-loading')?.remove();
            const allDates = new Set();
            players.forEach(player => { if (player.hittingByDate) { Object.keys(player.hittingByDate).forEach(dateKey => { if (dateKey !== todayKey) { allDates.add(dateKey); } }); } });
            const sortedDates = Array.from(allDates).sort().reverse();
            if (sortedDates.length === 0) { hittingLogSection.innerHTML = `<div class="bg-white p-4 rounded-lg shadow-sm text-center text-gray-500">No past hitting data found.</div>`; return; }
            const groups = [ { title: 'Liberos', positions: ['Libero'] }, { title: 'Outsides', positions: ['Outside'] }, { title: 'Middles / Opposites / Setters', positions: ['Middle', 'Opposite', 'Setter'] }];
            hittingLogSection.innerHTML = sortedDates.map(dateKey => {
                const displayDate = new Date(dateKey + 'T00:00:00').toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                const playersWithStatsOnDate = players.filter(p => p.hittingByDate && p.hittingByDate[dateKey] && (p.hittingByDate[dateKey].kills > 0 || p.hittingByDate[dateKey].errors > 0));
                if (playersWithStatsOnDate.length === 0) return '';

                let teamTotalKillsOnDate = 0;
                let teamTotalErrorsOnDate = 0;
                players.forEach(p => {
                    const hits = (p.hittingByDate || {})[dateKey] || { kills: 0, errors: 0 };
                    teamTotalKillsOnDate += hits.kills;
                    teamTotalErrorsOnDate += hits.errors;
                });
                const teamTotalAttemptsOnDate = teamTotalKillsOnDate + teamTotalErrorsOnDate;
                const teamHitPercentOnDate = teamTotalAttemptsOnDate > 0 ? ((teamTotalKillsOnDate / teamTotalAttemptsOnDate) * 100).toFixed(1) : '0.0';

                let playerHtml = groups.map(group => {
                    const playersInGroup = playersWithStatsOnDate.filter(p => p.position && group.positions.includes(p.position)).sort((a, b) => a.name.localeCompare(b.name));
                    if (playersInGroup.length === 0) return '';
                    const playerRows = playersInGroup.map(player => {
                        const hits = player.hittingByDate[dateKey] || { kills: 0, errors: 0 };
                        const total = hits.kills + hits.errors;
                        const percent = total > 0 ? ((hits.kills / total) * 100).toFixed(1) : '0.0';
                        return `<div class="flex justify-between items-center py-2 border-b border-gray-100"><span class="font-medium">${player.name}</span><span class="text-gray-600">Hit %: <span class="font-bold text-gray-800">${percent}%</span> (${hits.kills}K / ${hits.errors}E)</span></div>`;
                    }).join('');
                    return `<h3 class="text-md font-semibold text-indigo-700 mt-4 mb-2">${group.title}</h3><div>${playerRows}</div>`;
                }).join('');
                const unassignedPlayers = playersWithStatsOnDate.filter(p => !p.position).sort((a,b) => a.name.localeCompare(b.name));
                if (unassignedPlayers.length > 0) {
                     const playerRows = unassignedPlayers.map(player => {
                        const hits = player.hittingByDate[dateKey] || { kills: 0, errors: 0 };
                        const total = hits.kills + hits.errors;
                        const percent = total > 0 ? ((hits.kills / total) * 100).toFixed(1) : '0.0';
                        return `<div class="flex justify-between items-center py-2 border-b border-gray-100"><span class="font-medium">${player.name}</span><span class="text-gray-600">Hit %: <span class="font-bold text-gray-800">${percent}%</span> (${hits.kills}K / ${hits.errors}E)</span></div>`;
                    }).join('');
                    playerHtml += `<h3 class="text-md font-semibold text-indigo-700 mt-4 mb-2">Unassigned</h3><div>${playerRows}</div>`;
                }
                return `<div class="bg-white rounded-lg shadow-md">
                    <div class="hitting-log-toggle p-6 cursor-pointer">
                        <div class="flex justify-between items-center">
                            <div>
                                <h2 class="text-xl font-bold text-gray-800">${displayDate}</h2>
                                <p class="text-sm text-gray-500">Team Hit %: <span class="font-semibold">${teamHitPercentOnDate}%</span> (${teamTotalKillsOnDate}K / ${teamTotalErrorsOnDate}E)</p>
                            </div>
                             <div class="flex items-center space-x-4">
                                <button data-date-key="${dateKey}" class="change-hitting-date-btn text-sm text-indigo-600 hover:underline font-semibold z-10 relative">Change Date</button>
                                <svg class="chevron-icon w-6 h-6 text-gray-400 transform transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                </svg>
                            </div>
                        </div>
                    </div>
                    <div class="hitting-log-details hidden px-6 pb-6">
                        <div class="border-t pt-4">
                            ${playerHtml}
                        </div>
                    </div>
                </div>`;
            }).join('');
        };

        const renderHittingProgress = (players) => {
            document.getElementById('hitting-progress-loading')?.remove();
            if (players.length === 0) {
                hittingProgressSection.innerHTML = `<div class="bg-white p-4 rounded-lg shadow-sm text-center text-gray-500">Add players to the roster to see hitting progress charts.</div>`;
                return;
            }
            hittingProgressSection.innerHTML = '';
            players.sort((a, b) => a.name.localeCompare(b.name)).forEach(player => {
                const hittingByDate = player.hittingByDate || {};
                const practiceDates = Object.keys(hittingByDate).sort();
                
                const chartContainer = document.createElement('div');
                chartContainer.className = 'bg-white p-6 rounded-lg shadow-md';
                chartContainer.id = `hitting-chart-container-${player.id}`;
                hittingProgressSection.appendChild(chartContainer);

                if (practiceDates.length < 2) {
                     chartContainer.innerHTML = `<h3 class="font-bold text-lg text-indigo-700">${player.name}</h3><p class="text-gray-500 text-sm mt-2">Not enough data to show hitting progress. At least two practices are needed.</p>`;
                    return;
                }
                const chartData = { labels: [], percentages: [] };
                practiceDates.forEach(dateKey => {
                    const hits = hittingByDate[dateKey] || { kills: 0, errors: 0 };
                    const total = hits.kills + hits.errors;
                    if (total > 0) {
                        const percent = (hits.kills / total) * 100;
                        chartData.labels.push(new Date(dateKey + 'T00:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                        chartData.percentages.push(percent);
                    }
                });

                chartContainer.innerHTML = `<h3 class="font-bold text-lg text-indigo-700 mb-4">${player.name}'s Hitting Progress</h3>`;
                const canvas = document.createElement('canvas');
                chartContainer.appendChild(canvas);

                if (hittingPlayerCharts[player.id]) { hittingPlayerCharts[player.id].destroy(); }
                hittingPlayerCharts[player.id] = new Chart(canvas.getContext('2d'), {
                    type: 'line',
                    data: { labels: chartData.labels, datasets: [{ label: 'Hit Percentage', data: chartData.percentages, borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.1)', fill: true, tension: 0.1 }] },
                    options: { scales: { y: { beginAtZero: true, max: 100, ticks: { callback: function(value) { return value + '%'; } } } }, responsive: true, maintainAspectRatio: true }
                });
            });
        };
        
        const openPlayerSelectModal = () => {
            modalTitle.textContent = `Assign Rating: ${selectedRating}`;
            const groups = [ { title: 'Liberos', positions: ['Libero'] }, { title: 'Outsides', positions: ['Outside'] }, { title: 'Middles / Opposites / Setters', positions: ['Middle', 'Opposite', 'Setter'] }];
            const assignedPositions = groups.flatMap(g => g.positions);
            const playerButtonHtml = (player) => `<button data-id="${player.id}" class="player-select-btn w-full text-left p-3 rounded-lg bg-gray-100 hover:bg-indigo-100">${player.name}</button>`;
            let modalHtml = groups.map(group => {
                const playersInGroup = playersCache.filter(p => p.position && group.positions.includes(p.position)).sort((a, b) => a.name.localeCompare(b.name));
                if (playersInGroup.length === 0) return '';
                return `<div class="mb-3"><h3 class="text-sm font-semibold text-gray-500 mb-2 px-2">${group.title}</h3><div class="space-y-2">${playersInGroup.map(playerButtonHtml).join('')}</div></div>`;
            }).join('');
            const unassignedPlayers = playersCache.filter(p => !p.position || !assignedPositions.includes(p.position)).sort((a, b) => a.name.localeCompare(b.name));
            if (unassignedPlayers.length > 0) {
                modalHtml += `<div class="mb-3"><h3 class="text-sm font-semibold text-gray-500 mb-2 px-2">Unassigned</h3><div class="space-y-2">${unassignedPlayers.map(playerButtonHtml).join('')}</div></div>`;
            }
            modalPlayerList.innerHTML = modalHtml;
            if (modalPlayerList.innerHTML.trim() === '') {
                 modalPlayerList.innerHTML = `<p class="text-center text-gray-500">No players found in the roster.</p>`;
            }
            playerSelectModal.classList.remove('hidden');
        };

        const closePlayerSelectModal = () => {
            playerSelectModal.classList.add('hidden');
            modalPlayerList.innerHTML = '';
            document.querySelectorAll('.rating-button').forEach(btn => btn.classList.remove('active'));
            selectedRating = null;
        };

        const openHittingPlayerSelectModal = () => {
            hittingModalTitle.textContent = `Assign: ${selectedHittingAction}`;
            const groups = [ { title: 'Liberos', positions: ['Libero'] }, { title: 'Outsides', positions: ['Outside'] }, { title: 'Middles / Opposites / Setters', positions: ['Middle', 'Opposite', 'Setter'] }];
            const assignedPositions = groups.flatMap(g => g.positions);
            const playerButtonHtml = (player) => `<button data-id="${player.id}" class="hitting-player-select-btn w-full text-left p-3 rounded-lg bg-gray-100 hover:bg-indigo-100">${player.name}</button>`;
            let modalHtml = groups.map(group => {
                const playersInGroup = playersCache.filter(p => p.position && group.positions.includes(p.position)).sort((a, b) => a.name.localeCompare(b.name));
                if (playersInGroup.length === 0) return '';
                return `<div class="mb-3"><h3 class="text-sm font-semibold text-gray-500 mb-2 px-2">${group.title}</h3><div class="space-y-2">${playersInGroup.map(playerButtonHtml).join('')}</div></div>`;
            }).join('');
            const unassignedPlayers = playersCache.filter(p => !p.position || !assignedPositions.includes(p.position)).sort((a, b) => a.name.localeCompare(b.name));
            if (unassignedPlayers.length > 0) {
                modalHtml += `<div class="mb-3"><h3 class="text-sm font-semibold text-gray-500 mb-2 px-2">Unassigned</h3><div class="space-y-2">${unassignedPlayers.map(playerButtonHtml).join('')}</div></div>`;
            }
            hittingModalPlayerList.innerHTML = modalHtml;
            if (hittingModalPlayerList.innerHTML.trim() === '') {
                 hittingModalPlayerList.innerHTML = `<p class="text-center text-gray-500">No players found in the roster.</p>`;
            }
            hittingPlayerSelectModal.classList.remove('hidden');
        };

        const closeHittingPlayerSelectModal = () => {
            hittingPlayerSelectModal.classList.add('hidden');
            hittingModalPlayerList.innerHTML = '';
            document.querySelectorAll('.hitting-action-button').forEach(btn => btn.classList.remove('active'));
            selectedHittingAction = null;
        };

        const openDateChangeModal = (dateKey) => {
            editingDateKey = dateKey;
            dateChangeInput.value = dateKey;
            dateChangeModal.classList.remove('hidden');
        };

        const closeDateChangeModal = () => {
            editingDateKey = null;
            dateChangeModal.classList.add('hidden');
        };

        // --- Firestore Logic ---
        const listenForRosterChanges = () => {
            if (!rosterCollectionRef) return;
            onSnapshot(rosterCollectionRef, (snapshot) => {
                playersCache = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderRosterList(playersCache.sort((a,b) => a.name.localeCompare(b.name)));
                renderStatsList(playersCache);
                renderLog(playersCache);
                renderProgress(playersCache);
                renderHittingStatsList(playersCache);
                renderHittingLog(playersCache);
                renderHittingProgress(playersCache);
            }, (error) => {
                console.error("Error listening to roster changes: ", error);
                 let errorMessage = "Error fetching roster.";
                 if (error.code === 'permission-denied') { errorMessage = "Database permissions error. Please update your Firestore security rules."; }
                 rosterList.innerHTML = `<div class="text-center p-4 text-red-500">${errorMessage}</div>`;
                 statsList.innerHTML = `<div class="text-center p-4 text-red-500">${errorMessage}</div>`;
                 logSection.innerHTML = `<div class="text-center p-4 text-red-500">${errorMessage}</div>`;
                 progressSection.innerHTML = `<div class="text-center p-4 text-red-500">${errorMessage}</div>`;
                 hittingStatsList.innerHTML = `<div class="text-center p-4 text-red-500">${errorMessage}</div>`;
                 hittingLogSection.innerHTML = `<div class="text-center p-4 text-red-500">${errorMessage}</div>`;
                 hittingProgressSection.innerHTML = `<div class="text-center p-4 text-red-500">${errorMessage}</div>`;
            });
        };
        const handleAddPlayer = async () => {
            const name = playerNameInput.value.trim();
            const position = document.getElementById('player-position-select').value;
            if (name && position && rosterCollectionRef) {
                try { await addDoc(rosterCollectionRef, { name: name, position: position, statsByDate: {}, hittingByDate: {} }); playerNameInput.value = ''; } 
                catch (error) { console.error("Error adding player: ", error); }
            }
        };
        const handleDeletePlayer = async (playerId) => {
            if (!currentTeamId) return;
            try { await deleteDoc(doc(db, "teams", currentTeamId, "roster", playerId)); } 
            catch (error) { console.error("Error deleting player: ", error); }
        };
        const handleAssignPass = async (playerId) => {
            if (selectedRating === null || !currentTeamId) return;
            try {
                const playerDocRef = doc(db, "teams", currentTeamId, "roster", playerId);
                const playerDocSnap = await getDoc(playerDocRef);
                if (playerDocSnap.exists()) {
                    const currentStats = playerDocSnap.data().statsByDate || {};
                    const todayPasses = currentStats[todayKey] || [];
                    const updatedTodayPasses = [...todayPasses, selectedRating];
                    const updatedStats = { ...currentStats, [todayKey]: updatedTodayPasses };
                    await updateDoc(playerDocRef, { statsByDate: updatedStats });
                    ratingHelper.textContent = `Assigned '${selectedRating}'! Select another rating.`;
                }
            } catch (error) { console.error("Error assigning pass: ", error); }
            finally { closePlayerSelectModal(); }
        };

        const handleAssignHittingAction = async (playerId) => {
            if (selectedHittingAction === null || !currentTeamId) return;
            try {
                const playerDocRef = doc(db, "teams", currentTeamId, "roster", playerId);
                const playerDocSnap = await getDoc(playerDocRef);
                if (playerDocSnap.exists()) {
                    const currentHitting = playerDocSnap.data().hittingByDate || {};
                    const todayHits = currentHitting[todayKey] || { kills: 0, errors: 0 };
                    
                    if (selectedHittingAction === 'kill') {
                        todayHits.kills += 1;
                    } else if (selectedHittingAction === 'error') {
                        todayHits.errors += 1;
                    }
                    
                    const updatedHitting = { ...currentHitting, [todayKey]: todayHits };
                    await updateDoc(playerDocRef, { hittingByDate: updatedHitting });
                    hittingHelper.textContent = `Assigned '${selectedHittingAction}'! Select another action.`;
                }
            } catch (error) { console.error("Error assigning hitting action: ", error); }
            finally { closeHittingPlayerSelectModal(); }
        };
        
        const handleDateChangeSave = async () => {
            const oldDateKey = editingDateKey;
            const newDateKey = dateChangeInput.value;
            if (!oldDateKey || !newDateKey || oldDateKey === newDateKey) {
                closeDateChangeModal();
                return;
            }

            const playersToUpdate = playersCache.filter(p => 
                (p.statsByDate && p.statsByDate[oldDateKey]) || 
                (p.hittingByDate && p.hittingByDate[oldDateKey] && (p.hittingByDate[oldDateKey].kills > 0 || p.hittingByDate[oldDateKey].errors > 0))
            );
            
            if(playersToUpdate.length === 0) {
                closeDateChangeModal();
                return;
            }

            const updatePromises = playersToUpdate.map(player => {
                const playerDocRef = doc(db, "teams", currentTeamId, "roster", player.id);
                const updateData = {};
                
                // Handle passing stats
                if (player.statsByDate && player.statsByDate[oldDateKey]) {
                    const statsByDate = player.statsByDate;
                    const passesToMove = statsByDate[oldDateKey];
                    const existingPassesOnNewDate = statsByDate[newDateKey] || [];
                    const mergedPasses = [...existingPassesOnNewDate, ...passesToMove];
                    
                    const newStatsByDate = { ...statsByDate };
                    delete newStatsByDate[oldDateKey];
                    newStatsByDate[newDateKey] = mergedPasses;
                    updateData.statsByDate = newStatsByDate;
                }
                
                // Handle hitting stats
                if (player.hittingByDate && player.hittingByDate[oldDateKey]) {
                    const hittingByDate = player.hittingByDate;
                    const hitsToMove = hittingByDate[oldDateKey];
                    const existingHitsOnNewDate = hittingByDate[newDateKey] || { kills: 0, errors: 0 };
                    
                    const mergedHits = {
                        kills: existingHitsOnNewDate.kills + hitsToMove.kills,
                        errors: existingHitsOnNewDate.errors + hitsToMove.errors
                    };
                    
                    const newHittingByDate = { ...hittingByDate };
                    delete newHittingByDate[oldDateKey];
                    newHittingByDate[newDateKey] = mergedHits;
                    updateData.hittingByDate = newHittingByDate;
                }

                return updateDoc(playerDocRef, updateData);
            });

            try {
                await Promise.all(updatePromises);
            } catch (error) {
                console.error("Error changing practice date:", error);
            } finally {
                closeDateChangeModal();
            }
        };

        const handleDownloadCSV = () => {
            if (playersCache.length === 0) return;
            let csvContent = "Player Name,Position,Overall Passing Average\n";
            playersCache.forEach(player => {
                const statsByDate = player.statsByDate || {};
                const allPasses = Object.values(statsByDate).flat();
                const passCount = allPasses.length;
                const passSum = allPasses.reduce((sum, current) => sum + current, 0);
                const overallAverage = passCount > 0 ? (passSum / passCount).toFixed(2) : '0.00';
                csvContent += `"${player.name}","${player.position || 'N/A'}",${overallAverage}\n`;
            });
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8,' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            const exportDate = new Date().toISOString().split('T')[0];
            link.setAttribute("download", `volleyball_stats_${currentTeamId}_${exportDate}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        const handleDownloadHittingCSV = () => {
            if (playersCache.length === 0) return;
            let csvContent = "Player Name,Position,Total Kills,Total Errors,Total Attempts,Hit Percentage\n";
            playersCache.forEach(player => {
                const hittingByDate = player.hittingByDate || {};
                let totalKills = 0;
                let totalErrors = 0;
                Object.values(hittingByDate).forEach(hits => {
                    totalKills += hits.kills || 0;
                    totalErrors += hits.errors || 0;
                });
                const totalAttempts = totalKills + totalErrors;
                const hitPercent = totalAttempts > 0 ? ((totalKills / totalAttempts) * 100).toFixed(1) : '0.0';
                csvContent += `"${player.name}","${player.position || 'N/A'}",${totalKills},${totalErrors},${totalAttempts},${hitPercent}%\n`;
            });
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8,' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            const exportDate = new Date().toISOString().split('T')[0];
            link.setAttribute("download", `volleyball_hitting_stats_${currentTeamId}_${exportDate}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        // --- Event Listeners ---
        joinTeamBtn.addEventListener('click', handleJoinTeam);
        createTeamBtn.addEventListener('click', handleCreateTeam);
        joinTeamCodeInput.addEventListener('keyup', (e) => { if(e.key === 'Enter') handleJoinTeam(); });
        createTeamCodeInput.addEventListener('keyup', (e) => { if(e.key === 'Enter') handleCreateTeam(); });

        switchTeamBtn.addEventListener('click', handleSwitchTeam);
        teamCodeDisplay.addEventListener('click', () => {
            navigator.clipboard.writeText(currentTeamId).then(() => {
                teamCodeDisplay.title = 'Copied!';
                setTimeout(() => { teamCodeDisplay.title = 'Click to copy'; }, 2000);
            });
        });
        
        const subTabs = [ { btn: statsTabBtn, section: statsSection }, { btn: logTabBtn, section: logSection }, { btn: progressTabBtn, section: progressSection }];
        subTabs.forEach(tab => {
            tab.btn.addEventListener('click', () => {
                subTabs.forEach(t => { t.section.classList.add('hidden'); t.btn.classList.remove('active'); });
                tab.section.classList.remove('hidden');
                tab.btn.classList.add('active');
            });
        });

        const hittingSubTabs = [ { btn: hittingStatsTabBtn, section: hittingStatsSection }, { btn: hittingLogTabBtn, section: hittingLogSection }, { btn: hittingProgressTabBtn, section: hittingProgressSection }];
        hittingSubTabs.forEach(tab => {
            tab.btn.addEventListener('click', () => {
                hittingSubTabs.forEach(t => { t.section.classList.add('hidden'); t.btn.classList.remove('active'); });
                tab.section.classList.remove('hidden');
                tab.btn.classList.add('active');
            });
        });

        const mainTabs = [ { btn: mainPassingTabBtn, section: passingContentSection }, { btn: mainHittingTabBtn, section: hittingContentSection }];
        mainTabs.forEach(tab => {
            tab.btn.addEventListener('click', () => {
                mainTabs.forEach(t => { t.section.classList.add('hidden'); t.btn.classList.remove('active'); });
                tab.section.classList.remove('hidden');
                tab.btn.classList.add('active');
            });
        });
        
        addPlayerBtn.addEventListener('click', handleAddPlayer);
        playerNameInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') handleAddPlayer(); });
        
        rosterList.addEventListener('click', (e) => {
            const deleteBtn = e.target.closest('.delete-player-btn');
            if (deleteBtn) {
                handleDeletePlayer(deleteBtn.dataset.id);
                return;
            }
        });
        
        passingContentSection.addEventListener('click', (e) => {
            // Handle player name click to see progress
            const playerNameLink = e.target.closest('.player-name-link');
            if (playerNameLink) {
                const playerId = playerNameLink.dataset.playerId;
                // Switch to progress tab
                subTabs.forEach(t => {
                    t.section.classList.add('hidden'); t.btn.classList.remove('active');
                });
                progressSection.classList.remove('hidden');
                progressTabBtn.classList.add('active');
                
                // Scroll to chart
                setTimeout(() => {
                    const chartElement = document.getElementById(`chart-container-${playerId}`);
                    if (chartElement) {
                        chartElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        chartElement.style.transition = 'box-shadow 0.2s ease-in-out';
                        chartElement.style.boxShadow = '0 0 0 3px rgba(79, 70, 229, 0.5)';
                        setTimeout(() => { chartElement.style.boxShadow = ''; }, 2000);
                    }
                }, 50);
            }
        });
        
        logSection.addEventListener('click', (e) => {
            const changeDateBtn = e.target.closest('.change-date-btn');
            if (changeDateBtn) {
                openDateChangeModal(changeDateBtn.dataset.dateKey);
                return;
            }

            const header = e.target.closest('.log-toggle');
            if (header) {
                const details = header.nextElementSibling;
                const icon = header.querySelector('.chevron-icon');
                details.classList.toggle('hidden');
                icon.classList.toggle('rotate-180');
            }
        });

        hittingLogSection.addEventListener('click', (e) => {
            const changeDateBtn = e.target.closest('.change-hitting-date-btn');
            if (changeDateBtn) {
                openDateChangeModal(changeDateBtn.dataset.dateKey);
                return;
            }

            const header = e.target.closest('.hitting-log-toggle');
            if (header) {
                const details = header.nextElementSibling;
                const icon = header.querySelector('.chevron-icon');
                details.classList.toggle('hidden');
                icon.classList.toggle('rotate-180');
            }
        });

        hittingContentSection.addEventListener('click', (e) => {
            const playerNameLink = e.target.closest('.hitting-player-name-link');
            if (playerNameLink) {
                const playerId = playerNameLink.dataset.playerId;
                hittingSubTabs.forEach(t => {
                    t.section.classList.add('hidden'); t.btn.classList.remove('active');
                });
                hittingProgressSection.classList.remove('hidden');
                hittingProgressTabBtn.classList.add('active');
                
                setTimeout(() => {
                    const chartElement = document.getElementById(`hitting-chart-container-${playerId}`);
                    if (chartElement) {
                        chartElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        chartElement.style.transition = 'box-shadow 0.2s ease-in-out';
                        chartElement.style.boxShadow = '0 0 0 3px rgba(16, 185, 129, 0.5)';
                        setTimeout(() => { chartElement.style.boxShadow = ''; }, 2000);
                    }
                }, 50);
            }
        });

        ratingButtonsContainer.addEventListener('click', (e) => {
            const button = e.target.closest('.rating-button');
            if (button) { selectedRating = parseInt(button.dataset.rating, 10); document.querySelectorAll('.rating-button').forEach(btn => btn.classList.remove('active')); button.classList.add('active'); openPlayerSelectModal(); }
        });

        hittingActionButtonsContainer.addEventListener('click', (e) => {
            const button = e.target.closest('.hitting-action-button');
            if (button) { selectedHittingAction = button.dataset.action; document.querySelectorAll('.hitting-action-button').forEach(btn => btn.classList.remove('active')); button.classList.add('active'); openHittingPlayerSelectModal(); }
        });
        
        modalPlayerList.addEventListener('click', (e) => { const button = e.target.closest('.player-select-btn'); if (button) { handleAssignPass(button.dataset.id); } });
        modalCancelBtn.addEventListener('click', closePlayerSelectModal);

        hittingModalPlayerList.addEventListener('click', (e) => { const button = e.target.closest('.hitting-player-select-btn'); if (button) { handleAssignHittingAction(button.dataset.id); } });
        hittingModalCancelBtn.addEventListener('click', closeHittingPlayerSelectModal);
        
        dateChangeCancelBtn.addEventListener('click', closeDateChangeModal);
        dateChangeSaveBtn.addEventListener('click', handleDateChangeSave);
        
        downloadCsvBtn.addEventListener('click', handleDownloadCSV);
        downloadHittingCsvBtn.addEventListener('click', handleDownloadHittingCSV);

        // --- App Initialization ---
        async function initApp() {
             try {
                await signInAnonymously(auth);
                const savedTeamId = localStorage.getItem('vollystats_teamId');
                if (savedTeamId) { loadTeam(savedTeamId); }
            } catch (error) {
                console.error("Authentication failed:", error);
                teamError.textContent = "Could not connect to authentication service.";
            }
        }
        initApp();
    </script>
</body>
</html>
